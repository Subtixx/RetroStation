#!/usr/bin/env python
# Simple Quiz Game Engine in PyGame
# for Batocera Retrotrivia
# lbrpdx - 2020/2021
# https://github.com/lbrpdx/retrotrivia
# License: LGPL 3.0
import pygame
import pygame.freetype
import random
import questions
import gamelists
import videoplayer
import os
import sys
import psutil
import logging
import unicodedata
import math
import threading

#######################################
### Global parameters
DEBUG            = 1
TIMER            = 30  # seconds to respond
NUMBER_Q         = 10  # number of questions to ask
PLAYERS          = 1   # default nb of players
SOUND_VOL        = 5   # default volume (0 to 5)
WINDOW_SURFACE   = pygame.HWSURFACE|pygame.DOUBLEBUF
SYS_FONT         = './assets/Bifocals.otf'
FONT             = None
FONT_SIZE        = 40
TEXT_COLOR       = 'black'
TEXT_HALO        = 'cadetblue3'
TEXT_HALO_MENU   = 'plum'
TEXT_HALO_TIMER  = 'white'
BOX_COLOR        = 'blue'
BOX_COLOR_ANSWER = 'green'
BOX_COLOR_WRONG  = 'red'
BOX_WIDTH        = 4
TIMER_COLOR      = 'green'
TIMER_COLOR_END  = 'red'
GAMEMODES_NAMES  = [ 'Video', 'Trivia', 'Pixel', 'Rotate', 'Zoom' ]
GAMEMODES        = [ 1, 1, 1, 1, 1 ]
PLAYERS_MAX      = 4
NUM_QUESTIONS_MAX= 30
TIMER_MAX        = 30
SCREEN           = None
JOYSTICKS        = [ None, None, None, None ]
LOGGER           = logging.getLogger()
AUDIO_FREQ       = 44100
AUDIO_BUFFER     = 4096
VIDEO_EXTENSIONS = [ '.mp4', '.mkv', '.avi', '.m4v' ]
PADS_LAST_AT     = {}

#######################################
###  wrap/render text on a surface
class DrawText:
    circle_cache = {}

    def up(self, text):
        try:
            text = unicode(text, 'utf-8')
        except: # Python 2+3 compatibility
            pass
        text = unicodedata.normalize('NFD', text).encode('ascii', 'ignore').decode("utf-8")
        return str(text.upper())

    def __init__(self, surface, text, color, halo_color, rect, yoffset=0, lineSpacing=1, defopx=5):
        opx = defopx*SCREEN.get_height()//1080
        text = (self.up(text)).split('\n')
        rendtext = FONT.render("TgM") # Sample text to render
        fontHeight = int(rendtext[1][3])
        y = rect.top + fontHeight * yoffset
        for line in text:
            while line:
                i = 1
                # determine if the row of text will be outside our Rect area
                if y + fontHeight > rect.bottom:
                    break
                # determine maximum width of line
                while (FONT.render(line[:i])[1][2] < rect.width) and (i < len(line)):
                    i += 1
                # if we wrap the line, then adjust to the last word
                if i < len(line):
                    i = line.rfind(" ", 0, i) + 1
                # render the line and blit it to the surface
                image = FONT.render(line[:i], color)
                itxt = image[0].convert_alpha()
                w = itxt.get_width() + 2 * opx
                h = fontHeight + 2 * opx
                osurf = pygame.Surface((w, h)).convert_alpha()
                osurf.fill((0, 0, 0, 0))
                surf = osurf.copy()
                osurf.blit(FONT.render(line[:i], halo_color)[0].convert_alpha(), (0, 0))
                for dx, dy in circlepoints(opx, self.circle_cache):
                    surf.blit(osurf, (dx + opx, dy + opx))
                surf.blit(itxt, (opx, opx))
                surface.blit(surf, (rect.left, y))
                y += int(fontHeight *(1 + 0.2* lineSpacing))
                # remove the text we just blitted
                line = line[i:]
        return # line contains remaining text

#########################################
## Manage sound from multiple objects (otherwise : crash)
class SoundManager:
    def __init__(self):
        self.sound = None
        self.vol   = 0
        self.last  = 0
        pygame.mixer.pre_init(frequency=AUDIO_FREQ, buffer=AUDIO_BUFFER)
        pygame.mixer.init()
        pygame.mixer.init(frequency=AUDIO_FREQ, buffer=AUDIO_BUFFER)

    def volume(self, new_vol):
        self.vol = new_vol

    def wait(self, delay):
        pygame.mixer.music.pause()
        now = pygame.time.get_ticks()
        self.last = now
        while (now - self.last < delay):
            pygame.time.wait(10)
            now = pygame.time.get_ticks()
        pygame.mixer.music.unpause()

    def play(self, sound_file, delay=0):
        if pygame.mixer.get_busy():
            pygame.mixer.music.stop()
        if not os.path.isfile(sound_file):
            return
        if self.vol > 0:
            pygame.mixer.music.load(sound_file)
            pygame.mixer.music.play(0)
            if delay > 0:
                thr = threading.Thread(target=self.wait, args=[delay])
                thr.daemon = True
                thr.start()

#########################################
## log messages to stdout
def log(message):
    global DEBUG
    global LOGGER
    if DEBUG > 0:
        LOGGER.debug(message)

#########################################
## Joystick/pad/keyboard events
def key_pressed(event, joypads):
    global DEBUG
    if (event.type == pygame.KEYDOWN and joypads == None):
        log ("Keyboard event: {}".format(event.key))
        # Always player 1 for keyboard
        if event.key == pygame.K_UP:
            return (0, 'up')
        elif event.key == pygame.K_LEFT:
            return (0, 'left')
        elif event.key == pygame.K_RIGHT:
            return (0, 'right')
        elif event.key == pygame.K_DOWN:
            return (0, 'down')
        elif event.key in (97, 98):  # A and B keys
            return (0, 'action')
    if joypads == None:
        return (-1, -1) # keyboard/pad2key only, no initialized joypad
    for joypad in joypads:
        if joypad == None:
            continue
        id = joypad.get_instance_id()
        if event.type == pygame.JOYAXISMOTION:  # Analogue Hat
            try:
                if joypad.get_axis(1) <= -1:
                    log("Joypad {}: axis {} up".format(id, joypad.get_axis(1)))
                    return (id, 'up')
                elif joypad.get_axis(0) <= -1:
                    log("Joypad {}: axis {} left".format(id, joypad.get_axis(0)))
                    return (id, 'left')
                elif joypad.get_axis(0) >= 0.5:
                    log("Joypad {}: axis {} right".format(id, joypad.get_axis(0)))
                    return (id, 'right')
                elif joypad.get_axis(1) >= 0.5:
                    log("Joypad {}: axis {} down".format(id, joypad.get_axis(1)))
                    return (id, 'down')
            except Exception as e:
                    log("Joypad {} error: {}".format(id, e))
        elif event.type == pygame.JOYHATMOTION:  # Digital Hat
            try:
                log("Joypad {}: hat {}".format(id, joypad.get_hat(0)))
                if joypad.get_hat(0) == (0,1):
                    return (id, 'up')
                elif joypad.get_hat(0) == (-1,0):
                    return (id, 'left')
                elif joypad.get_hat(0) == (1,0):
                    return (id, 'right')
                elif joypad.get_hat(0) == (0,-1):
                    return (id, 'down')
            except Exception as e:
                    log("Joypad {} error: {}".format(id, e))
        elif event.type == pygame.JOYBUTTONDOWN:
            if DEBUG > 0:
                for k in range (joypad.get_numbuttons()):
                    if joypad.get_button(k):
                        log ("Joypad {}: button {}".format(id,k))
            try:
                if joypad.get_button(0):  # Buttons A or B
                    return (id, 'action')
                elif joypad.get_button(1):  # Buttons A or B
                    return (id, 'action')
                elif joypad.get_button(8):
                    return (id, 'up')
                elif joypad.get_button(10):
                    return (id, 'left')
                elif joypad.get_button(11):
                    return (id, 'right')
                elif joypad.get_button(9):
                    return (id, 'down')
                elif joypad.get_button(13):
                    return (id, 'up')
                elif joypad.get_button(15):
                    return (id, 'left')
                elif joypad.get_button(16):
                    return (id, 'right')
                elif joypad.get_button(14):
                    return (id, 'down')
                elif joypad.get_button(2):  # Buttons A or B
                    return (id, 'action')
                elif joypad.get_button(3):  # Buttons A or B
                    return (id, 'action')
            except Exception as e:
                    log("Joypad {} error: {}".format(id, e))
    return (-1, -1) # No event

######################################
### Colorize icon
def colorize_icon(image, color):
    newimage = image.copy()
    newimage.fill((0, 0, 0, 255), None, pygame.BLEND_RGBA_MULT)
    newimage.fill(color[0:3] + (0,), None, pygame.BLEND_RGBA_ADD)
    return newimage

#######################################
### List and types of questions
class QuestionBank:
    triviabank     = []
    videobank      = []
    loaded         = 0          # number of questions loaded
    gamemode       = GAMEMODES  # Also save settings here
    timer          = TIMER
    number_q       = NUMBER_Q
    sound_vol      = SOUND_VOL
    players        = PLAYERS
    timerplayers   = [0, 0, 0, 0]
    loaded_pcent   = 0

    def __init__(self):
        pass

    def load_all(self):
        self.loaded_pcent = 0
        self.triviabank = questions.Q[:]
        self.loaded += len (self.triviabank)
        gl = gamelists.gamelist()
        i = 0
        for sys in gl.systems:
                loaded_sys = gl.load(sys)
                self.videobank += loaded_sys[:]
                i += 1
                self.loaded_pcent = int(100*i/len(gl.systems))
                log("Loaded system {} with {} games.".format(sys, len(loaded_sys)))
        self.loaded += len (self.videobank)
        log("Total questions loaded: {} trivia, {} questions including videos".format(len(self.triviabank), self.loaded))

    def initialize_Q(self):
        thr = threading.Thread(target=self.load_all, args=())
        thr.daemon = True
        thr.start()

#######################################
### Current Game state
class GameState:
    QB = None

    def __init__(self, QB):
        self.current_question   = None
        self.current_mode       = 0
        self.QB                 = QB
        self.questionst         = {}   # trivia questions
        self.questionsv         = {}   # video thumbnails questions
        self.right              = [ 0, 0, 0, 0 ]
        self.wrong              = [ 0, 0, 0, 0 ]
        self.score              = [ 0, 0, 0, 0 ]
        self.numq               = 0     # what question are we at?
        self.numqansw           = 0     # what question have we answered?

    def pop_question(self):
        log ("GameState pop question")
        if len (self.questionst) < (self.QB.number_q - self.numqansw):
            self.questionst = self.QB.triviabank[:]
        # Remind: GAMEMODES_NAMES = [ 'Video', 'Trivia', 'Pixel', 'Rotate', 'Zoom' ]
        if self.QB.gamemode[0] == 1 or self.QB.gamemode[2] == 1\
                                    or self.QB.gamemode[3] == 1 or self.QB.gamemode[4] == 1:
            if len (self.questionsv) < (self.QB.number_q - self.numqansw):
                self.questionsv = self.QB.videobank[:]
        ntry = 0
        self.current_mode = (self.current_mode+1) % len(GAMEMODES)
        while (ntry < len(self.QB.gamemode) and self.QB.gamemode[self.current_mode] == 0):
            self.current_mode = (self.current_mode+1) % len(GAMEMODES)
            ntry += 1
        if self.QB.gamemode[self.current_mode] == 0:
            self.current_mode = 1 # Force trivia (even if not selected, because nothing else)
        self.numq += 1
        log("Question {} mode {}: ({})".format(str(self.numq), str(self.current_mode), GAMEMODES_NAMES[self.current_mode]))
        # Video (normal, pixelated, rotated or zoomed)
        if self.current_mode == 0 or self.current_mode == 2\
                                  or self.current_mode == 3 or self.current_mode == 4:
                try:
                    q = random.choice(self.questionsv)
                    self.questionsv.remove(q)
                except: # not enough videos
                    q = random.choice(self.questionst)
                    self.questionst.remove(q)
        else:
            q = random.choice(self.questionst)
            self.questionst.remove(q)
        self.current_question = q
        log("Question: {}".format(str(q)))
        return q

    def get_answer(self, vinput, timerpl):
        if self.numqansw < self.numq:
            self.numqansw += 1
            ret = False
            for p in range(self.QB.players):
                if vinput[p] == self.current_question[1]:
                    self.right[p] += 1
                    self.score[p] += timerpl[p]
                    log ("Question {} was right at {} sec for player {}".format(self.numqansw, timerpl[p], p+1))
                    ret = True
                else:
                    self.wrong[p] += 1
                    self.score[p] -= timerpl[p]
                    if self.score[p] < 0:
                        self.score[p] = 0 # No negative score, too depressing
                    log ("Question {} was wrong at {} sec for player {}".format(self.numqansw, timerpl[p], p+1))
            return ret

    def get_result(self):
        log ("Game Over")
        res = ""
        if self.QB.players > 1:
            for p in range(self.QB.players):
                res += "Player {}: {} points\n".format(p+1,self.score[p])
                res += "  ({} right, {} wrong answers)\n".format(self.right[p],self.wrong[p])
            res += "\n \nPlayer 1, press [A] to continue"
            return res
        else:
            if self.score[0] > self.QB.number_q * self.QB.timer/2:
                tagline="GREAT SCORE!\n "
            elif self.score[0] > self.QB.number_q:
                tagline="NOT TOO BAD.\n "
            elif self.score[0] > self.QB.number_q/2:
                tagline="YOU CAN DO BETTER NEXT TIME.\n "
            else:
                tagline="OK, WE WON'T JUDGE YOU...\n"
            tright = '\n{} answers were correct\n'.format(self.right[0]) if self.right[0]>1 \
                else '\nhuh, {} answer was correct\n'.format(self.right[0])
            twrong = '{} answers were wrong'.format(self.wrong[0]) if self.wrong[0]>1 \
                else 'and, wow, {} answer was wrong'.format(self.wrong[0])
            return 'FINAL SCORE: {}\n'.format(self.score[0])+tagline+tright+twrong \
                          +'\n \nPress [A] to continue'


#######################################
### Simple static Screen
class StaticScreen:
    QB = None
    circle_cache = {}

    def __init__(self, next_scene, img, text):
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.square = int(SCREEN.get_height()/20)
        self.img = img if img else None
        self.additional_text = text if text else None
        self.next_scene = next_scene

    def start(self, text):
        opx = 5*SCREEN.get_height()//1080
        self.back_img = pygame.image.load('assets/back_cover.jpg')
        self.back_img = pygame.transform.scale(self.back_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.background.blit(self.back_img, (0, 0))
        if self.img:
            self.foreground = pygame.image.load(self.img)
            img_ratio = float(float(self.foreground.get_width())/self.foreground.get_height())
            self.foreground = pygame.transform.scale(self.foreground, (int(SCREEN.get_width()/8*img_ratio),
                        int(SCREEN.get_width()/8)))
            backdrop = colorize_icon(self.foreground.convert_alpha(), pygame.Color(TEXT_HALO_MENU))
            w = backdrop.get_width() + 2 * opx
            h = backdrop.get_height() + 2 * opx
            osurf = pygame.Surface((w, h)).convert_alpha()
            osurf.fill((0, 0, 0, 0))
            surf = osurf.copy()
            osurf.blit(backdrop, (0, 0))
            for dx, dy in circlepoints(opx, self.circle_cache):
                surf.blit(osurf, (dx - opx//2, dy - opx//2))
            surf.blit(backdrop, (opx, opx))
            self.background.blit(surf, (int(SCREEN.get_width()*0.375), int(SCREEN.get_height()/8)))
            self.background.blit(self.foreground, (int(SCREEN.get_width()*0.375), int(SCREEN.get_height()/8)))
        if text:
            if self.additional_text == None:
                self.additional_text = text
            else:
                self.additional_text += text
        self.draw()

    def additional(self, text):
        self.additional_text = text

    def draw(self):
        SCREEN.blit(self.background, (0, 0))
        if self.additional_text:
            p_surface=pygame.Rect(SCREEN.get_width()*0.375, SCREEN.get_height()*0.3,\
                      SCREEN.get_width()/2, SCREEN.get_height()/2)
            DrawText(self.background, self.additional_text, TEXT_COLOR, TEXT_HALO_MENU, p_surface, 3, 2, defopx=8)
            self.additional_text = None

    def update(self, events, dt):
        for event in events:
            if key_pressed (event, [JOYSTICKS[0]]) == (0, 'action'):
                return (self.next_scene, None)

    def initialize_QB(self):
        if self.QB == None:
            self.QB = QuestionBank()
            self.QB.initialize_Q()


#######################################
### Settings
class SettingsScreen:
    QB = None

    def __init__(self, QB):
        self.QB = QB
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.rects_set, self.rects_down, self.rects_val, self.rects_up = [], [], [], []
        x = SCREEN.get_width()//25
        y = SCREEN.get_height()//8
        self.square = int(SCREEN.get_height()/12)
        self.settings = [ 'NUMBER OF QUESTIONS', 'TIME LIMIT', 'SOUND VOLUME', 'PLAYERS', 'GAME MODES' ]
        self.settings_val = [ NUMBER_Q, TIMER, SOUND_VOL, PLAYERS, GAMEMODES[:] ]
        for n in range(4):
            rect_set   = pygame.Rect(x, y, int(SCREEN.get_width()/5+self.square), self.square)
            rect_down  = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*1.5), y, self.square, self.square)
            rect_val   = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*3.0), y, self.square, self.square)
            rect_up    = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*4.5), y, self.square, self.square)
            self.rects_set.append(rect_set)
            self.rects_down.append(rect_down)
            self.rects_val.append(rect_val)
            self.rects_up.append(rect_up)
            y += int(self.square*1.1)
        # Gamemodes (1/2)
        self.rects_gmodes = pygame.Rect(x, y, int(SCREEN.get_width()/5+self.square), self.square)
        self.rects_gmode = []
        self.rects_gmval = []
        for i in range(2):
            self.rects_gmval.append(pygame.Rect(int(x+SCREEN.get_width()/5+self.square*(1.5+3*i)), y, self.square, self.square))
            self.rects_gmode.append(pygame.Rect(int(x+SCREEN.get_width()/5+self.square*(2.5+3*i)), y, 2*self.square, self.square))
        y += int(self.square*1.1)
        for i in range(3):
            self.rects_gmval.append(pygame.Rect(int(x+SCREEN.get_width()/5+self.square*(1.5+3*i)), y, self.square, self.square))
            self.rects_gmode.append(pygame.Rect(int(x+SCREEN.get_width()/5+self.square*(2.5+3*i)), y, 2*self.square, self.square))
        y += int(self.square*1.1)
        # default and start button
        self.rects_defaults   = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*1.5), y, self.square*3, self.square)
        self.rects_start      = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*4.5), y, self.square*3, self.square)
        # ysel = 5rd row, 2nd button
        self.xsel, self.ysel = 1, 6
        self.up_down = [ ]
        self.up_img = pygame.image.load('assets/chevron_up.png')
        self.up_img = pygame.transform.scale(self.up_img, (self.square, self.square))
        self.up_down.append(self.up_img)
        self.up_img = pygame.transform.rotate(self.up_img,180)
        self.up_down.append(self.up_img)
        self.right_icon = pygame.image.load('assets/right.png')
        self.right_icon = pygame.transform.scale(self.right_icon, (self.square, self.square))
        self.wrong_icon = pygame.image.load('assets/wrong.png')
        self.wrong_icon = pygame.transform.scale(self.wrong_icon, (self.square, self.square))
        self.static_bkg_img = pygame.image.load('assets/back_cover.jpg')
        self.static_bkg_img = pygame.transform.scale(self.static_bkg_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        self.background.blit(self.static_bkg_img, (0, 0))

    def start(self, *args):
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        self.background.blit(self.back_img, (0, 0))
        p_surface=pygame.Rect(SCREEN.get_width()*3/8, SCREEN.get_height()/100,\
                  SCREEN.get_width()/3, SCREEN.get_height()/10)
        DrawText(self.background, 'SETTINGS', TEXT_COLOR, TEXT_HALO_MENU, p_surface, 1, 1)
        p_surface2=pygame.Rect(SCREEN.get_width()*3/8, SCREEN.get_height()*8/10,\
                  SCREEN.get_width()/3, SCREEN.get_height()/10)
        DrawText(self.background, '[HOTKEY]+[START] TO QUIT', TEXT_COLOR, TEXT_HALO_MENU, p_surface2, 1, 1)
        n = 0
        for rect in self.rects_val:
            DrawText(self.background, self.settings[n], TEXT_COLOR, TEXT_HALO_MENU, self.rects_set[n], 1, 1)
            n += 1
        DrawText(self.background, self.settings[n], TEXT_COLOR, TEXT_HALO_MENU, self.rects_gmodes, 1, 1)
        for i in range(len(self.rects_gmode)):
            DrawText(self.background, GAMEMODES_NAMES[i], TEXT_COLOR, TEXT_HALO_MENU, self.rects_gmode[i], 1, 1)

    def draw(self):
        SCREEN.blit(self.background, (0, 0))
        n = 0
        for rect in self.rects_val:
            color = BOX_COLOR if (n == self.ysel and self.xsel == 0) else TEXT_HALO_MENU
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_down[n], int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
            self.background.blit(self.up_down[1], (self.rects_down[n].x,self.rects_down[n].y))
            subsurface = self.static_bkg_img.subsurface(self.rects_val[n])
            self.background.blit(subsurface, (self.rects_val[n].x, self.rects_val[n].y))
            rct = pygame.Rect(self.rects_val[n].x+self.square/10, self.rects_val[n].y+self.square/3, self.square, self.square)
            DrawText(self.background, str(self.settings_val[n]), TEXT_COLOR, TEXT_HALO_MENU, rct)
            self.background.blit(self.up_down[0], (self.rects_up[n].x,self.rects_up[n].y))
            color = BOX_COLOR if (n == self.ysel and self.xsel == 1) else TEXT_HALO_MENU
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_up[n], int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
            n += 1
        for i in range(2):
            ico = self.right_icon if self.settings_val[4][i] == 1 else self.wrong_icon
            subsurface = self.static_bkg_img.subsurface(self.rects_gmval[i])
            self.background.blit(subsurface, (self.rects_gmval[i].x, self.rects_gmval[i].y))
            self.background.blit(ico, (self.rects_gmval[i].x,self.rects_gmval[i].y))
            color = BOX_COLOR if (4 == self.ysel and self.xsel == i) else TEXT_HALO_MENU
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_gmval[i], int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
        for i in range(3):
            ico = self.right_icon if self.settings_val[4][2+i] == 1 else self.wrong_icon
            subsurface = self.static_bkg_img.subsurface(self.rects_gmval[2+i])
            self.background.blit(subsurface, (self.rects_gmval[2+i].x, self.rects_gmval[2+i].y))
            self.background.blit(ico, (self.rects_gmval[2+i].x,self.rects_gmval[2+i].y))
            color = BOX_COLOR if (5 == self.ysel and self.xsel == i) else TEXT_HALO_MENU
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_gmval[2+i], int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
        # defaults and start buttons
        color = BOX_COLOR if (6 == self.ysel and self.xsel == 0) else TEXT_HALO_MENU
        pygame.draw.rect(self.background, pygame.Color(color), self.rects_defaults, int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
        rct = pygame.Rect(self.rects_defaults.x+self.square/3, self.rects_defaults.y+self.square/3, self.square*3, self.square)
        DrawText(self.background, 'DEFAULTS', TEXT_COLOR, TEXT_HALO_MENU, rct)
        color = BOX_COLOR if (6 == self.ysel and self.xsel == 1) else TEXT_HALO_MENU
        pygame.draw.rect(self.background, pygame.Color(color), self.rects_start, int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
        rct = pygame.Rect(self.rects_start.x+self.square/2, self.rects_defaults.y+self.square/3, self.square*3, self.square)
        greylevel = int(math.sin(math.radians(pygame.time.get_ticks()/5%360))*127)
        DrawText(self.background, 'START', (32+greylevel/4, 128+greylevel, 64+greylevel/2), TEXT_HALO_MENU, rct)

    def action(self):
        if self.ysel == 0:
            # Number of questions
            if self.xsel == 0:
                self.settings_val[0] -= 1
                if self.settings_val[0] < 5:
                    self.settings_val[0] = 5
            elif self.xsel == 1:
                self.settings_val[0] += 1
                if self.settings_val[0] > NUM_QUESTIONS_MAX:
                    self.settings_val[0] = NUM_QUESTIONS_MAX # 50 questions max
        elif self.ysel == 1:
            # Time limit
            if self.xsel == 0:
                self.settings_val[1] -= 1
                if self.settings_val[1] < 5:
                    self.settings_val[1] = 5
            elif self.xsel == 1:
                self.settings_val[1] += 1
                if self.settings_val[1] > TIMER_MAX:
                    self.settings_val[1] = TIMER_MAX # 60 sec max
        elif self.ysel == 2:
            # Sound volume
            if self.xsel == 0:
                self.settings_val[2] -= 1
                if self.settings_val[2] < 0:
                    self.settings_val[2] = 0
            elif self.xsel == 1:
                self.settings_val[2] += 1
                if self.settings_val[2] > SOUND_VOL:
                    self.settings_val[2] = SOUND_VOL
        elif self.ysel == 3:
            # Number players
            if self.xsel == 0:
                self.settings_val[3] -= 1
                if self.settings_val[3] < 1:
                    self.settings_val[3] = 1
            elif self.xsel == 1:
                self.settings_val[3] += 1
                if self.settings_val[3] > PLAYERS_MAX:
                    self.settings_val[3] = PLAYERS_MAX # 4 players max
        elif self.ysel == 4:
            # Game mode
            for i in range(2):
                if self.xsel == i:
                    self.settings_val[4][i] = (self.settings_val[4][i]+1)%2
        elif self.ysel == 5:
            # video tricks
            for i in range(3):
                if self.xsel == i:
                    self.settings_val[4][2+i] = (self.settings_val[4][2+i]+1)%2
        elif self.ysel == 6:
            # Default and Start
            if self.xsel == 0:
                self.settings_val = [ NUMBER_Q, TIMER, SOUND_VOL, PLAYERS, GAMEMODES[:] ]
            elif self.xsel == 1:
                self.QB.number_q  = self.settings_val[0]
                self.QB.timer     = self.settings_val[1]
                self.QB.sound_vol = self.settings_val[2]
                self.QB.players   = self.settings_val[3]
                self.QB.gamemode  = self.settings_val[4]
                log("Number of questions: {}, timer: {}, players: {}, sound vol: {}".format(self.QB.number_q, self.QB.timer, self.QB.players, self.QB.sound_vol))
                log("Selected gamemodes: {}".format(self.QB.gamemode))
                return ('QUIZ', GameState(self.QB))

    def update(self, events, dt):
        for event in events:
            if key_pressed(event, JOYSTICKS)[1] == 'up':
                self.ysel = (self.ysel-1) % (len(self.settings)+2)
                if (self.ysel !=5) and (self.xsel > 1):
                    self.xsel = 1
            elif key_pressed(event, JOYSTICKS)[1] == 'left':
                if (self.ysel == 4):
                    self.xsel = (self.xsel-1) % 2 # 2 options on this line
                elif (self.ysel == 5):
                    self.xsel = (self.xsel-1) % 3 # 3 options on this line
                else:
                    self.xsel = (self.xsel-1) % 2
            elif key_pressed(event, JOYSTICKS)[1] == 'right':
                if (self.ysel == 4):
                    self.xsel = (self.xsel+1) % 2 # 2 options on this line
                elif (self.ysel == 5):
                    self.xsel = (self.xsel+1) % 3 # 3 options on this line
                else:
                    self.xsel = (self.xsel+1) % 2
            elif key_pressed(event, JOYSTICKS)[1] == 'down':
                self.ysel = (self.ysel+1) % (len(self.settings)+2)
                if (self.ysel != 5) and (self.xsel > 1):
                    self.xsel = 1
            elif key_pressed(event, JOYSTICKS)[1] == 'action':
                return self.action()

######################################
### Larger countdown
def circlepoints(r, ccache):
    r = int(round(r))
    if r in ccache:
        return ccache[r]
    x, y, e = r, 0, 1 - r
    ccache[r] = points = []
    while x >= y:
        points.append((x, y))
        y += 1
        if e < 0:
            e += 2 * y - 1
        else:
            x -= 1
            e += 2 * (y - x) - 1
    points += [(y, x) for x, y in points if x > y]
    points += [(-x, y) for x, y in points if x]
    points += [(x, -y) for x, y in points if y]
    points.sort()
    return points

class Timer(pygame.sprite.Sprite):
    circle_cache = {}

    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
        self.image = None
        self.font = pygame.font.Font(SYS_FONT, 5 * int(FONT_SIZE*SCREEN.get_height()/1080))

    def update (self, passed_time, max_timer, opx=8):
        # Larger font for the timer
        opx=opx*SCREEN.get_height()//1080
        font_color = pygame.Color(TIMER_COLOR_END) if passed_time <= 5 else pygame.Color(TIMER_COLOR)
        text = str(passed_time if passed_time < max_timer else max_timer)
        textsurface = self.font.render(text, True, font_color).convert_alpha()
        w = textsurface.get_width() + 2 * opx
        h = self.font.get_height()
        osurf = pygame.Surface((w, h + 2 * opx)).convert_alpha()
        osurf.fill((0, 0, 0, 0))
        surf = osurf.copy()
        osurf.blit(self.font.render(text, True, TEXT_HALO_TIMER).convert_alpha(), (0, 0))
        for dx, dy in circlepoints(opx, self.circle_cache):
            surf.blit(osurf, (dx + opx, dy + opx))
        surf.blit(textsurface, (opx, opx))
        self.image = surf
        self.rect = (int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.15))

######################################
### Quizz Game Scene
class QuizScreen:
    def __init__(self):
        self.square = int(SCREEN.get_height()/10)
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.right_icon = pygame.image.load('assets/right.png')
        self.right_icon = pygame.transform.scale(self.right_icon, (self.square, self.square))
        self.wrong_icon = pygame.image.load('assets/wrong.png')
        self.wrong_icon = pygame.transform.scale(self.wrong_icon, (self.square, self.square))
        self.static_bkg_img = pygame.image.load('assets/back_q.jpg')
        self.static_bkg_img = pygame.transform.scale(self.static_bkg_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.scorefont = pygame.font.Font(SYS_FONT, int(FONT_SIZE*SCREEN.get_height()/1080))
        self.back_img = self.static_bkg_img.copy()
        self.background.blit(self.back_img, (0, 0))
        self.q_surface = None
        self.vsprite = None
        self.vsprite_group = None
        self.reveal = False
        self.rects = []
        self.resps = []
        x = int(10 + SCREEN.get_width()/20)
        y = int(SCREEN.get_height()/2 + self.square)
        self.arrows = [ ]
        self.arrow_img = pygame.image.load('assets/arrow.png')
        self.arrow_img = pygame.transform.scale(self.arrow_img, (self.square, self.square))
        self.arrows.append(self.arrow_img)
        for i in range (3):
            self.arrow_img = pygame.transform.rotate(self.arrow_img,90)
            self.arrows.append(self.arrow_img)
        ricox = [ int(x + SCREEN.get_width()*0.8 /2 /2),
                      int(x),
                      int(x + SCREEN.get_width()*0.8 /2 /2),
                      int(x + SCREEN.get_width()*0.8 /2) ]
        ricoy = [ int(y),
                      int(y + int(self.square*1.1)),
                      int(y + 2*int(self.square*1.1)),
                      int(y + int(self.square*1.1)) ]
        self.small_arrows = []
        for img in self.arrows:
            timg = pygame.transform.scale(img, (self.square//2, self.square//2))
            self.small_arrows.append(timg)
        readyimg = pygame.image.load('assets/ready.png')
        self.small_ready = pygame.transform.scale(readyimg, (int(self.square/1.5), self.square//2))
        for n in range(4):
            rect = pygame.Rect(ricox[n], ricoy[n], self.square, self.square)
            resp = pygame.Rect(int(ricox[n]+self.square*1.2), int(ricoy[n]+self.square*0.2), int(SCREEN.get_width()*0.8/2-self.square*1.2), self.square)
            self.rects.append(rect)
            self.resps.append(resp)
        self.countdown = Timer()
        self.sound_manager = SoundManager()
    log ("Initialized QuizScreen")

    def start(self, gamestate):
        self.gamestate = gamestate
        self.sound_manager.volume(gamestate.QB.sound_vol)
        self.r = []
        for n in range(5):
            self.r.append('')
        self.question, self.answer, self.r[1], self.r[2], self.r[3], self.r[4] = gamestate.pop_question()
        # Clean and draw question
        if self.vsprite_group is not None:
            if self.vsprite is not None:
                self.vsprite_group.remove(self.vsprite)
                self.vsprite = None
            self.vsprite_group = None
        self.q_surface = pygame.Rect(int(self.square*2.2), int(self.square/5),\
            int((SCREEN.get_height()/2.1+self.square*3/5)*(4/3)), int(SCREEN.get_height()/2.1+self.square*3/5))

        if (self.question[-4:].rstrip()) in VIDEO_EXTENSIONS:
            # Surface video player
            if self.gamestate.current_mode == 2:
                mode = "pixelated"
            elif self.gamestate.current_mode == 3:
                mode = "rotated"
            elif self.gamestate.current_mode == 4:
                mode = "zoom"
            else:
                mode = "regular"
            self.vsprite = videoplayer.VideoSprite(self.q_surface, self.question, self.sound_manager, mode)
            self.vsprite_group = pygame.sprite.Group()
            self.vsprite_group.add(self.vsprite)
        else:
            self.vsprite = None
            self.vsprite_group = None
        self.contsurf = pygame.Rect(int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.82),\
                                int(SCREEN.get_width()*0.2), int(SCREEN.get_height()*0.18))
        self.timer_started = True
        self.start_time = pygame.time.get_ticks() + gamestate.QB.timer * 1000 + 950 # margin to draw screen
        self.passed_time = self.start_time
        self.reveal = False
        self.vinput = [ 0, 0, 0, 0 ]
        self.ready  = [ 0, 0, 0, 0 ]
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        if (self.question[-4:].rstrip()) not in VIDEO_EXTENSIONS:
            DrawText(self.back_img, self.question, TEXT_COLOR, TEXT_HALO, self.q_surface, 3, 2)
        n = 1
        for rect in self.rects:
            DrawText(self.back_img, self.r[n], TEXT_COLOR, TEXT_HALO, self.resps[n-1])
            n += 1
        self.countdown_list = pygame.sprite.Group()
        self.countdown_list.add(self.countdown)

    def draw(self):
        self.background.blit(self.back_img, (0, 0))
        SCREEN.blit(self.background, (0, 0))
        n = 1
        for rect in self.rects:
            # Color boxes
            col      = BOX_COLOR
            wid      = BOX_WIDTH
            self.back_img.blit(self.arrows[n-1], (rect.x, rect.y))
            if self.reveal:
                for p in range(self.gamestate.QB.players):
                    if n == self.vinput[p]:
                        pygame.draw.rect(self.back_img, pygame.Color(TEXT_COLOR), rect, 0, border_radius=self.square//4) # 0 = fill
                        ico = colorize_icon(self.wrong_icon, pygame.Color(BOX_COLOR_WRONG))
                        self.back_img.blit(ico, (rect.x, rect.y))
                    if n == self.answer:
                        pygame.draw.rect(self.back_img, pygame.Color(TEXT_COLOR), rect, 0, border_radius=self.square//4) # 0 = fill
                        ico = colorize_icon(self.right_icon, pygame.Color(BOX_COLOR_ANSWER))
                        self.back_img.blit(ico, (rect.x, rect.y))
            n += 1
        # Timer and scores
        subsurface = self.static_bkg_img.subsurface((int(SCREEN.get_width()*0.8),0,int(SCREEN.get_width()*0.2),SCREEN.get_height()*0.7))
        self.back_img.blit(subsurface, (int(SCREEN.get_width()*0.8), 0))
        # Video player (except if Trivia)
        if (self.question[-4:].rstrip()) in VIDEO_EXTENSIONS:
            subsurface2 = self.static_bkg_img.subsurface(0,0,int(SCREEN.get_width()*0.8),int(SCREEN.get_height()/2.1+self.square))
            self.back_img.blit(subsurface2, (0, 0))
        all_answered = 1
        if self.reveal:
            cont_text = "Everyone, " if self.gamestate.QB.players>1 else "Player 1, "
            cont_text += "\n press [A]\n  to continue"
            greylevel = int(math.sin(math.radians(pygame.time.get_ticks()/5%360))*127)
            DrawText(self.back_img, cont_text, (32+greylevel/4 ,128+greylevel, 64+greylevel/2), TEXT_HALO, self.contsurf, 0, 2)
        scorey= int(SCREEN.get_height()*0.4)
        rct = pygame.Rect(int(SCREEN.get_width()*0.8), scorey,\
                  int(SCREEN.get_width()*0.2), int(self.square//2))
        DrawText(self.back_img, 'SCORE BOARD:', TEXT_COLOR, TEXT_HALO, rct)
        for p in range(self.gamestate.QB.players):
            reponse     = pygame.Surface((0, 0))
            surfreponse = pygame.Rect(0, 0, 0, 0)
            ready       = pygame.Surface((0, 0))
            scorey += int(self.square*0.5)
            if self.reveal:
                if self.vinput[p] == 1:
                    reponse = self.small_arrows[0]
                    surfreponse = pygame.Rect(int(SCREEN.get_width()*0.9), scorey, self.square//2, self.square//2)
                elif self.vinput[p] == 2:
                    reponse = self.small_arrows[1]
                    surfreponse = pygame.Rect(int(SCREEN.get_width()*0.9), scorey, self.square//2, self.square//2)
                elif self.vinput[p] == 3:
                    reponse = self.small_arrows[2]
                    surfreponse = pygame.Rect(int(SCREEN.get_width()*0.9), scorey, self.square//2, self.square//2)
                elif self.vinput[p] == 4:
                    reponse = self.small_arrows[3]
                    surfreponse = pygame.Rect(int(SCREEN.get_width()*0.9), scorey, self.square//2, self.square//2)
            ready = self.small_ready if self.ready[p] else pygame.Surface((0,0))
            rct = pygame.Rect(int(SCREEN.get_width()*0.8), int(scorey+(self.square/10)),\
                  int(SCREEN.get_width()*0.2), int(self.square//2))
            DrawText(self.back_img, "P{}: {}".format(p+1,self.gamestate.score[p]), TEXT_COLOR, TEXT_HALO, rct)
            greylevel = int(math.sin(math.radians(pygame.time.get_ticks()/2%360))*63)
            if self.vinput[p] == self.answer:
                reponse = colorize_icon(reponse, pygame.Color(BOX_COLOR_ANSWER))
                small_rect_color = (0, 64+greylevel, 0)
            else:
                reponse = colorize_icon(reponse, pygame.Color(BOX_COLOR_WRONG))
                small_rect_color = (0, 0, 0)
            pygame.draw.rect(self.back_img, small_rect_color, surfreponse, 0, border_radius=self.square//8) # 0 = fill
            self.back_img.blit(reponse, (int(SCREEN.get_width()*0.9), scorey))
            self.back_img.blit(ready, (int(SCREEN.get_width()*0.93), scorey))
        rct = pygame.Rect((int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.05),\
                  int(SCREEN.get_width()*0.2), int(SCREEN.get_height()*0.10)))
        DrawText(self.back_img, 'QUESTION: {}/{}'.format(self.gamestate.numq,self.gamestate.QB.number_q),\
                  TEXT_COLOR, TEXT_HALO, rct)
        self.countdown_list.update(int(self.passed_time/1000), self.gamestate.QB.timer)
        self.countdown_list.draw(self.back_img)
        if self.vsprite_group is not None:
             self.vsprite_group.update(int(self.passed_time/1000), self.gamestate.QB.timer)
             self.vsprite_group.draw(self.back_img)

    def update(self, events, dt):
        if self.reveal == False :
            self.passed_time = self.start_time - pygame.time.get_ticks()
            for event in events:
                if self.gamestate.numqansw >= self.gamestate.numq:
                    break
                if self.reveal == False:
                    (p, ev) = key_pressed (event, JOYSTICKS)
                    if ev == 'up':
                        self.vinput[p] = 1
                        self.gamestate.QB.timerplayers[p] = int(self.passed_time/1000 \
                            if self.passed_time/1000 < self.gamestate.QB.timer else self.gamestate.QB.timer)
                    elif ev == 'left':
                        self.vinput[p] = 2
                        self.gamestate.QB.timerplayers[p] = int(self.passed_time/1000 \
                            if self.passed_time/1000 < self.gamestate.QB.timer else self.gamestate.QB.timer)
                    elif ev == 'right':
                        self.vinput[p] = 4
                        self.gamestate.QB.timerplayers[p] = int(self.passed_time/1000 \
                            if self.passed_time/1000 < self.gamestate.QB.timer else self.gamestate.QB.timer)
                    elif ev == 'down':
                        self.vinput[p] = 3
                        self.gamestate.QB.timerplayers[p] = int(self.passed_time/1000 \
                            if self.passed_time/1000 < self.gamestate.QB.timer else self.gamestate.QB.timer)
                all_answered = 1
                for p in range(self.gamestate.QB.players):
                    all_answered *= self.vinput[p]
                if all_answered:
                    res = self.gamestate.get_answer(self.vinput, self.gamestate.QB.timerplayers)
                    if self.gamestate.QB.sound_vol > 0:
                       if res:
                           self.sound_manager.play('assets/playerright.wav')
                       else:
                           self.sound_manager.play('assets/playeranswered.wav')
                    self.reveal = True
                    log("Reveal answer")
            if (self.passed_time <= 0):
                self.passed_time = 0
                self.reveal = True
                log("Time's up")
                self.sound_manager.play('assets/timeout.wav')
        else:
            try:
                if self.vsprite_group is not None:
                    if self.vsprite is not None:
                        if self.vsprite.video_stop is False:
                            log ("Stop video sprite")
                            self.vsprite.stop()
            except:
                log ("Error while killing video sprite")
                pass
            for event in events:
                ev = key_pressed (event, JOYSTICKS)
                all_ready = 1
                if ev[1] == 'action':
                    self.ready[ev[0]] = 1
                    for p in range(self.gamestate.QB.players):
                        all_ready *= self.ready[p]
                    if all_ready:
                        log ("Next screen")
                        if self.gamestate.numq < self.gamestate.QB.number_q:
                           return ('QUIZ', self.gamestate)
                        else:
                            score = self.gamestate.get_result()
                            del self.gamestate # Reset for next game
                            return ('RESULT', score)
            return None

#######################################
### Main Loop
def main():
    global FONT
    global SCREEN
    global JOYSTICKS
    global LOGGER
    global PLAYERS_MAX
    LOGGER.setLevel(logging.DEBUG)
    loghandler = logging.StreamHandler(sys.stderr)
    logformat = logging.Formatter('[%(asctime)s] %(message)s')
    loghandler.setFormatter(logformat)
    LOGGER.addHandler(loghandler)
    os.environ['SDL_AUDIODRIVER'] = 'alsa'
    pygame.mouse.set_visible(0)
    infoObject = pygame.display.Info()
    SCREEN = pygame.display.set_mode((infoObject.current_w, infoObject.current_h), WINDOW_SURFACE)
    log("Game screen: {}x{}".format(SCREEN.get_width(), SCREEN.get_height()))
    pygame.font.init()
    if FONT == None:
        FONT = pygame.freetype.Font(SYS_FONT, int(FONT_SIZE*SCREEN.get_height()/1080))
    pygame.joystick.init()
    njoy = pygame.joystick.get_count()
    log("Number of joysticks found: {}".format(njoy))
    for i in range(njoy):
        JOYSTICKS[i] = pygame.joystick.Joystick(i)
        JOYSTICKS[i].init()
        log("Joystick {} initialized as {} / {}".format(i, pygame.joystick.Joystick(i).get_guid(),\
             pygame.joystick.Joystick(i).get_instance_id()))
    PLAYERS_MAX = njoy if njoy <= PLAYERS_MAX else PLAYERS_MAX
    if PLAYERS_MAX == 0:
        PLAYERS_MAX = 1
    clock = pygame.time.Clock()
    dt = 0
    scenes =  {'TITLE'   : StaticScreen('SETTINGS', 'assets/logo.png', 'LOADING GAMES'),}
    scene = scenes['TITLE']
    scene.start(None)
    starttime = pygame.time.get_ticks()
    scene.draw()
    pygame.display.flip()
    scene.initialize_QB()
    while scene.QB.loaded_pcent < 100:
        scene.additional("LOADING GAMES {}%".format(scene.QB.loaded_pcent))
        scene.draw()
        pygame.display.flip()
        dt = clock.tick(60)
        pygame.time.wait(100) # 100ms
    delta = (pygame.time.get_ticks() - starttime) // 1000
    scene.start("\n\n{} QUESTIONS\nLOADED IN {} SEC\n \nPlayer 1 Press [A] to start\n \n[Hotkey]+[start] to quit".format(scene.QB.loaded, delta))
    scenes.update({
        'SETTINGS': SettingsScreen(scene.QB),
        'QUIZ'    : QuizScreen(),
        'RESULT'  : StaticScreen('TITLE', 'assets/score.png', ''),
    })
    while True:
        events = pygame.event.get(pump=True)
        for e in events:
            if e.type == pygame.QUIT:
                return
            try:
                if JOYSTICKS[0] and JOYSTICKS[0].get_button(12) and JOYSTICKS[0].get_button(17): # hotkey + start for player 1 only
                    return
            except:
                pass
        result = scene.update(events, dt)
        if result:
            next_scene, state = result
            if next_scene:
                scene = scenes[next_scene]
                scene.start(state)
        scene.draw()
        pygame.display.flip()
        dt = clock.tick(60)

if __name__ == '__main__':
    pygame.init()
    main()
